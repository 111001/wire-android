package com.waz.annotions.processing.builders;

import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.TypeName;
import com.squareup.javapoet.TypeSpec;
import com.waz.annotations.Controller;
import com.waz.annotations.Store;
import com.waz.annotions.processing.ProcessingException;
import com.waz.annotions.processing.types.CoreAnnotatedClass;

import javax.annotation.processing.Filer;
import javax.lang.model.element.Element;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.Modifier;
import javax.lang.model.util.Elements;
import javax.lang.model.util.Types;
import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public abstract class AbsFactoryBuilder<T extends CoreAnnotatedClass> extends Builder<T> {

    protected static final String PREFIX_INTERFACE = "I";

    protected static final String FACTORY_NAME_CONTROLLER = "ControllerFactory";
    protected static final String FACTORY_NAME_STORE = "StoreFactory";

    protected static final String PACKAGE_STORE = "com.waz.zclient.core.stores";
    protected static final String PACKAGE_CONTROLLER = "com.waz.zclient.controllers";

    public static final String AUTOGENERATED_WARNING = "This class was AUTOGENERATED.\n\nAll changes will be overwritten with the next build.\n";

    private Filer filer;

    /**
     * These two fields refer to the IControllerFactory or the IStoreFactory that the any ControllerFactory
     * or StoreFactory should inherit from.
     */
    private String interfacePackageName;
    private String interfaceName;

    protected String factoryName;

    protected Elements elementUtils;

    @Override
    public final void generate(Elements elementUtils, Types typeUtils, Filer filer) throws IOException {
        if (annotatedClasses.isEmpty()) {
            return;
        }
        this.filer = filer;
        this.elementUtils = elementUtils;
        setUpConfig();
        createFactory();
    }

    private void setUpConfig() {
        interfacePackageName = isControllerFactory() ? PACKAGE_CONTROLLER : PACKAGE_STORE;
        factoryName = isControllerFactory() ? FACTORY_NAME_CONTROLLER : FACTORY_NAME_STORE;
        interfaceName = PREFIX_INTERFACE + factoryName;
        extraConfig();
    }

    /**
     * A kind of init method that should be used to set up any useful variables after
     * {@link #generate(Elements, Types, Filer)} is called.
     */
    protected void extraConfig() {

    }

    protected final void createFactory() throws IOException {
        TypeSpec.Builder builder = TypeSpec.classBuilder(getClassName())
                                           .addSuperinterface(ClassName.get(interfacePackageName, interfaceName))
                                           .addJavadoc(AUTOGENERATED_WARNING)
                                           .addModifiers(Modifier.PUBLIC)
                                           .addMethods(generateFactoryMethods())
                                           .addFields(generateFactoryFields());

        TypeSpec typeSpec = modifyFactorySpec(builder);

        JavaFile.Builder javaFileBuilder = JavaFile.builder(getPackageName(), typeSpec);

        createFile(getSaveLocation(), modifyJavaFile(javaFileBuilder));
    }

    /**
     * Override this method to add anything else to the TypeSpec before creating the java source file. Make sure
     * to call builder.build() on the provided TypeSpec.Builder to get all of the default factory pieces
     * @param builder the builder to add modifications to
     * @return the built typespec. Alternatively you can discard the builder and provide a completely new
     * typespec.
     */
    protected TypeSpec modifyFactorySpec(TypeSpec.Builder builder) {
        return builder.build();
    }

    /**
     * @return What you want your factory to be called, e.g. Base$$ControlFactory.
     */
    protected abstract String getClassName();

    /**
     * @return the package name of your generated factory
     */
    protected abstract String getPackageName();

    /**
     * Only override this method if you DON'T want to save your java file to the generated sources directory
     * @return the place you want to save the generated source file, relative to the project root directoy,
     * e.g. "app/src/androidTest/java/". The package name of the class will also be appended to this location.
     */
    protected String getSaveLocation() {
        return null;
    }

    /**
     * Provides an opportunity to add extra things to the JavaFile that is used to create the java file. Override
     * this method to do things like add static imports or add java doc etc, or discard the builder and provide
     * another JavaFile altogether.
     * @param builder the default builder.
     * @return A JavaFile that will be used to create the java class file.
     */
    protected JavaFile modifyJavaFile(JavaFile.Builder builder) {
        return builder.build();
    }

    /**
     * Generates the FieldSpecs for all of the different Stores or Controllers that need to be accessed from
     * this Factory.
     * @return
     */
    protected final List<FieldSpec> generateFactoryFields() {
        final List<FieldSpec> fields = new ArrayList<>();
        for (T annotatedClass : annotatedClasses) {
            FieldSpec.Builder builder = FieldSpec.builder(ClassName.get(annotatedClass.getAnnotatedType()),
                                                          annotatedClass.getFieldName(),
                                                          Modifier.PROTECTED);
            fields.add(modifyField(builder, annotatedClass));
        }
        addExtraFields(fields);
        return fields;
    }

    /**
     * Provides an opportunity for sub classes to modify any of the Factory's Controller or Store instance fields.
     * This will be called for every Store or Controller that the Factory can provide
     * @param builder the default Builder used to create the FieldSpec for this particular Store or Controller instance.
     *                You can discard this to generated a completely new FieldSpec.
     * @param annotatedClass The AnnotatedClass instance representing either an annotated store or controller.
     * @return the FieldSpec representation of the Store or Controller instance for this factory.
     */
    protected FieldSpec modifyField(FieldSpec.Builder builder, T annotatedClass) {
        return builder.build();
    }

    /**
     * An opportunity for sub classes to add extra fields beyond just the default store and controller fields.
     * @param fields The current list of fields, which by now includes all of the store and controller instance fields.
     */
    protected void addExtraFields(List<FieldSpec> fields) {
    }

    /**
     * Generates all of the methods that must be overridden by either the IStoreFactory or IControllerFactory.
     * As each method is generated, this method will call to subclasses and ask them to complete whatever method
     * is currently being built by asking them to fill out the method body.
     * <p/>
     * Note, I can't think of a good way to trigger only Controller or only Store related method builders, so both
     * have to be called. If a subclass doesn't care about one of them, it can just return the builders in those
     * methods it doesn't need to fill out.
     *
     * @return
     */
    protected final Set<MethodSpec> generateFactoryMethods() {
        final Set<MethodSpec> methods = new HashSet<>();
        for (T annotatedClass : annotatedClasses) {
            MethodSpec.Builder builder = MethodSpec.methodBuilder(annotatedClass.getGetterName())
                                                   .addAnnotation(Override.class)
                                                   .addModifiers(Modifier.PUBLIC)
                                                   .returns(ClassName.get(annotatedClass.getAnnotatedType()));
            methods.add(modifyStoreOrControllerGetter(builder, annotatedClass));
        }

        if (isControllerFactory()) {
            methods.add(modifySetActivity(MethodSpec.methodBuilder("setActivity")
                                                    .returns(TypeName.VOID)
                                                    .addParameter(ClassName.get("android.app", "Activity"), "activity")
                                                    .addModifiers(Modifier.PUBLIC)
                                                    .addAnnotation(Override.class)));

            methods.add(modifySetGlobalLayout(MethodSpec.methodBuilder("setGlobalLayout")
                                                        .addModifiers(Modifier.PUBLIC)
                                                        .addAnnotation(Override.class)
                                                        .returns(TypeName.VOID)
                                                        .addParameter(ClassName.get("android.view", "View"),
                                                                      "globalLayoutView")));
        } else {
            methods.add(modifyReset(MethodSpec.methodBuilder("reset")
                                              .addModifiers(Modifier.PUBLIC)
                                              .addAnnotation(Override.class)
                                              .returns(TypeName.VOID)));
        }

        //Methods that must be inherited by both Store and Controller Factories
        methods.add(modifyTearDown(MethodSpec.methodBuilder("tearDown")
                                             .addModifiers(Modifier.PUBLIC)
                                             .addAnnotation(Override.class)
                                             .returns(TypeName.VOID)));
        methods.add(modifyIsTornDown(MethodSpec.methodBuilder("isTornDown")
                                               .addModifiers(Modifier.PUBLIC)
                                               .addAnnotation(Override.class)
                                               .returns(TypeName.BOOLEAN)));

        addExtraMethods(methods);

        return methods;
    }

    /**
     * Override this (and do not call super) in order to add extra properties to the Controller or Store getter metods.
     * This method is called once for each Store or Controller this factory represents
     * @param builder a builder representing a default getter method. Discard the builder to return a completely
     *                custom method.
     * @param annotatedClass the Store or Controller Annotated class
     * @return the MethodSpec representing the getter method.
     */
    protected MethodSpec modifyStoreOrControllerGetter(MethodSpec.Builder builder, T annotatedClass) {
        return builder.addStatement("return $L", annotatedClass.getFieldName())
                      .build();
    }

    /**
     * Override this (and do not call super) in order to add extra properties to the setActivity method.
     * @param builder a builder representing the method. Discard the builder to return a completely
     *                custom method.
     * @return the MethodSpec representing the method.
     */
    protected MethodSpec modifySetActivity(MethodSpec.Builder builder) {
        return builder.build();
    }

    /**
     * Override this (and do not call super) in order to add extra properties to the setGlobalLayout method.
     * @param builder a builder representing the method. Discard the builder to return a completely
     *                custom method.
     * @return the MethodSpec representing the method.
     */
    protected MethodSpec modifySetGlobalLayout(MethodSpec.Builder builder) {
        return builder.build();
    }

    /**
     * Override this (and do not call super) in order to add extra properties to the reset method.
     * @param builder a builder representing the method. Discard the builder to return a completely
     *                custom method.
     * @return the MethodSpec representing the method.
     */
    protected MethodSpec modifyReset(MethodSpec.Builder builder) {
        return builder.build();
    }

    /**
     * Override this (and do not call super) in order to add extra properties to the tearDown method.
     * @param builder a builder representing the method. Discard the builder to return a completely
     *                custom method.
     * @return the MethodSpec representing the method.
     */
    protected MethodSpec modifyTearDown(MethodSpec.Builder builder) {
        return builder.build();
    }

    /**
     * Override this (and do not call super) in order to add extra properties to the isTornDown method.
     * @param builder a builder representing the method. Discard the builder to return a completely
     *                custom method.
     * @return the MethodSpec representing the method.
     */
    protected MethodSpec modifyIsTornDown(MethodSpec.Builder builder) {
        return builder.addStatement("return false")
                      .build();
    }

    /**
     * Override this method if you want to add extra methods beyond the getters of the Store or Controller factory
     *
     * @param methodSpecs the method specs that by now has all of the getters built into it.
     */
    protected void addExtraMethods(Set<MethodSpec> methodSpecs) {
    }

    /**
     * Creates the java class file represented by javaFile. If no location is provided, then it will be saved
     * under the generated source code files. If a location is specified, it will be saved there instead.
     *
     * @param location an optional location in which to save the generated file, relative to the root of the project,
     *                 e.g. "app/src/androidTest/java/".
     * @param javaFile representing the java class and it's generated code.
     * @throws IOException
     */
    protected final void createFile(String location, JavaFile javaFile) throws IOException {
        if (location == null) {
            javaFile.writeTo(filer);
            return;
        }

        File directory = new File(location);
        directory = directory.getAbsoluteFile();
        Path path = !directory.exists() ? Files.createDirectories(directory.toPath()) : directory.toPath();
        javaFile.writeTo(path);
    }


    @Override
    public final void checkElement(Elements elementUtils,
                             Types typeUtils,
                             Element annotatedElement) throws ProcessingException {
        if (annotatedElement.getKind() != ElementKind.INTERFACE) {
            throw new ProcessingException(annotatedElement,
                                          "Only interfaces can be annotated with @%s or %s",
                                          Store.class.getSimpleName(),
                                          Controller.class.getSimpleName());
        }
    }

    /**
     * @return true if building a ControllerFactory, false if returning a StoreFactory.
     */
    protected boolean isControllerFactory() {
        return annotatedClasses.get(0).getSimpleName().contains("Controller");
    }
}
